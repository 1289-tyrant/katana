include_directories(include)
#add_subdirectory(lib)

if(EXP_DOALL MATCHES "GALOIS") 
  if(HAS_CXX0X_LAMBDA)
    add_definitions(-DEXP_DOALL_GALOIS)
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${CXX0X_FLAGS}")
  else()
    message(FATAL_ERROR "Asked for GALOIS but C++ lambda support not found")
  endif()
elseif(EXP_DOALL MATCHES "PTHREAD")
  add_definitions(-DEXP_DOALL_PTHREAD)
elseif(EXP_DOALL MATCHES "DMP") 
  add_definitions(-DEXP_DOALL_PTHREAD)
  add_definitions(-DGALOIS_USE_DMP)
  #  add_definitions(-DDMP_ENABLE_LIBHOARD)
  add_definitions(-emit-llvm)
  include_directories(lib/dmpruntime)
  set(OLD_CMAKE_CXX_COMPILER ${CMAKE_CXX_COMPILER})
  set(CMAKE_CXX_COMPILER ${CMAKE_CURRENT_SOURCE_DIR}/scripts/dmp-c++)
elseif(EXP_DOALL MATCHES "CILK")
  if(HAVE_CILK)
    add_definitions(-DEXP_DOALL_CILK)
  else()
    message(FATAL_ERROR "Asked for CILK but CILK not found")
  endif()
elseif(EXP_DOALL MATCHES "TBB")
  if(TBB_FOUND)
    if(HAS_CXX0X_LAMBDA)
      add_definitions(-DEXP_DOALL_TBB)
      set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${CXX0X_FLAGS}")
    else()
      message(FATAL_ERROR "Asked for TBB but C++ lambda support not found")
    endif()
  else()
    message(FATAL_ERROR "Asked for TBB but TBB not found")
  endif()
elseif(EXP_DOALL MATCHES "OPENMP" OR EXP_DOALL MATCHES "OPENMP_RUNTIME")
  find_package(OpenMP)
  if(OPENMP_FOUND)
    set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} ${OpenMP_CXX_FLAGS}")
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${OpenMP_CXX_FLAGS}")
    if (EXP_DOALL MATCHES "OPENMP")
      add_definitions(-DEXP_DOALL_OPENMP)
    else()
      add_definitions(-DEXP_DOALL_OPENMP_RUNTIME)
    endif()
  else()
    message(FATAL_ERROR "Asked for OPENMP but OPENMP was not found")
  endif()
else()
  message(FATAL_ERROR "Unknown DO_ALL type ${EXP_DOALL}")
endif()

add_custom_target(more-suites)

include(ParseArguments)

set(Parallel ${CMAKE_CURRENT_SOURCE_DIR}/src/Parallel.cpp)
file(GLOB DMPRUNTIME ${CMAKE_CURRENT_SOURCE_DIR}/lib/dmpruntime/*.cpp)
set(HOARD ${CMAKE_CURRENT_SOURCE_DIR}/lib/dmpruntime/libhoard/src/libhoard.cpp)

### Creates a real library instead of going through DMP route
function(addsuitelibrary target)
  if(OLD_CMAKE_CXX_COMPILER)
    remove_definitions(-emit-llvm)
    set(CMAKE_CXX_COMPILER ${OLD_CMAKE_CXX_COMPILER} PARENT_SCOPE)
  endif()
  add_library(${target} ${ARGN})
endfunction()

function(addsuite target)
  PARSE_ARGUMENTS(ADDSUITE "EXTLIBS" "" ${ARGN})
  # Statically link everything to enable DMP compilation
  if(EXP_DOALL MATCHES "DMP")
    add_executable(${target} ${ADDSUITE_DEFAULT_ARGS} ${Parallel} ${DMPRUNTIME})
  else()
    add_executable(${target} ${ADDSUITE_DEFAULT_ARGS} ${Parallel})
  endif()
  if(EXP_DOALL MATCHES "DMP")
    target_link_libraries(${target} rt dl)
  elseif(EXP_DOALL MATCHES "GALOIS")
    target_link_libraries(${target} ${RT_LINK} galois)
  endif()
  add_dependencies(more-suites ${target})
  set_target_properties(${target} PROPERTIES EXCLUDE_FROM_ALL true)
  target_link_libraries(${target} ${ADDSUITE_EXTLIBS})
  target_link_libraries(${target} pthread)
endfunction()

add_custom_target(more-suites-inputs)

add_subdirectory(pbbs-0.1)
if(EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/parsec-2.1")
  add_subdirectory(parsec-2.1)
else()
  message("Missing parsec-2.1 suite; run download_external.sh to download")
endif()
