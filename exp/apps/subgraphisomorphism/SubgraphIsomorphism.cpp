/** Subgraph isomorphism -*- C++ -*-
 * @file
 * @section License
 *
 * Galois, a framework to exploit amorphous data-parallelism in irregular
 * programs.
 *
 * Copyright (C) 2013, The University of Texas at Austin. All rights reserved.
 * UNIVERSITY EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES CONCERNING THIS
 * SOFTWARE AND DOCUMENTATION, INCLUDING ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR ANY PARTICULAR PURPOSE, NON-INFRINGEMENT AND WARRANTIES OF
 * PERFORMANCE, AND ANY WARRANTY THAT MIGHT OTHERWISE ARISE FROM COURSE OF
 * DEALING OR USAGE OF TRADE.  NO WARRANTY IS EITHER EXPRESS OR IMPLIED WITH
 * RESPECT TO THE USE OF THE SOFTWARE OR DOCUMENTATION. Under no circumstances
 * shall University be liable for incidental, special, indirect, direct or
 * consequential damages or loss of profits, interruption of business, or
 * related expenses which may arise from use of Software or Documentation,
 * including but not limited to those resulting from defects in Software and/or
 * Documentation, or loss or inaccuracy of data of any kind.
 *
 * @section Description
 *
 * Subgraph isomorphism.
 *
 * @author Yi-Shan Lu <yishanlu@cs.utexas.edu>
 */
#include "Galois/Galois.h"
#include "Galois/Bag.h"
#include "Galois/Statistic.h"
#include "Galois/Timer.h"
#include "Galois/Graphs/Graph.h"
#include "Galois/Graphs/TypeTraits.h"
#include "llvm/Support/CommandLine.h"
#include "Lonestar/BoilerPlate.h"
#include "Galois/Accumulator.h"
//#include "Galois/PerThreadContainer.h"

#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <atomic>
#include <set>

#include <chrono>
#include <random>

namespace cll = llvm::cl;

static const char* name = "Subgraph Isomorphism";
static const char* desc =
  "Computes up to k isomorphism on data graph for each query graph";
static const char* url = "subgraph_isomorphism";

enum Algo {
  ullmann, 
  vf2
};

static cll::opt<unsigned int> kFound("kFound", cll::desc("stop when k instances found"), cll::init(10));
static cll::opt<bool> undirected("undirected", cll::desc("undirected data and query graphs"), cll::init(false));

static cll::opt<std::string> graphD("graphD", cll::desc("<data graph file>"));
static cll::opt<std::string> graphQ("graphQ", cll::desc("<query graph file>"));

static cll::opt<unsigned int> numLabels("numLabels", cll::desc("# labels"), cll::init(2));

static cll::opt<bool> rndSeedQByTime("rndSeedQByTime", cll::desc("rndSeedQ generated by system time"), cll::init(false));
static cll::opt<unsigned int> rndSeedQ("rndSeedQ", cll::desc("random seed Q"), cll::init(0));

static cll::opt<bool> rndSeedDByTime("rndSeedDByTime", cll::desc("rndSeedD generated by system time"), cll::init(false));
static cll::opt<unsigned int> rndSeedD("rndSeedD", cll::desc("random seed D"), cll::init(0));

static cll::opt<Algo> algo("algo", cll::desc("Choose an algorithm:"),
    cll::values(
      clEnumValN(Algo::ullmann, "ullmann", "Ullmann (default)"),
      clEnumValN(Algo::vf2, "vf2", "VF2"), 
      clEnumValEnd), cll::init(Algo::ullmann));

struct DNode {
  char label;
  unsigned int id;
};

typedef Galois::Graph::LC_CSR_Graph<DNode, void> InnerDGraph; // graph with DNode nodes and typeless edges
typedef Galois::Graph::LC_InOut_Graph<InnerDGraph> DGraph;
typedef DGraph::GraphNode DGNode;

struct QNode {
  char label;
  unsigned int id;
  std::vector<DGNode> candidate;
};

typedef Galois::Graph::LC_CSR_Graph<QNode, void> InnerQGraph;
typedef Galois::Graph::LC_InOut_Graph<InnerQGraph> QGraph;
typedef QGraph::GraphNode QGNode;

struct NodeMatch {
  QGNode nQ;
  DGNode nD;
  NodeMatch(const QGNode q, const DGNode d): nQ(q), nD(d) {}
  NodeMatch(): nQ(), nD() {}
};

typedef std::vector<NodeMatch> Matching;
typedef Galois::InsertBag<Matching> MatchingVector;

static std::minstd_rand0 generator;
static std::uniform_int_distribution<unsigned> distribution;

static std::atomic_uint currentlyFound;

template<typename Graph>
void printGraph(Graph& g) {
  for(auto ni = g.begin(), ne = g.end(); ni != ne; ++ni) {
    auto& data = g.getData(*ni);
    std::cout << "node " << data.id << ": " << data.label << std::endl;
    for(auto ei = g.edge_begin(*ni), ee = g.edge_end(*ni); ei != ee; ++ei) {
      auto& dstData = g.getData(g.getEdgeDst(ei));
      std::cout << "  edge to node " << dstData.id << std::endl;
    }
  }
  std::cout << std::endl;
}

template<typename Graph>
void initializeGraph(Graph& g, unsigned int seed) {
  typedef typename Graph::node_data_type Node;

  generator.seed(seed);

  unsigned int i = 0;
  for(auto ni = g.begin(), ne = g.end(); ni != ne; ++ni) {
    Node& data = g.getData(*ni);
    data.id = i++;
    data.label = 'A' + distribution(generator) % numLabels;

    g.sortEdgesByDst(*ni);
  }
}

struct VF2Algo {
  std::string name() const { return "VF2"; }

  // instrumented stat
  static Galois::GReduceMax<size_t> dFrontierSize;

  class FilterCandidatesInternal {
    DGraph& gD;
    QGraph& gQ;
    Galois::GReduceLogicalOR& nodeEmpty;
    FilterCandidatesInternal(DGraph& d, QGraph& q, Galois::GReduceLogicalOR& lor): gD(d), gQ(q), nodeEmpty(lor) {}

  public:
    void operator()(const QGNode n) const {
      auto& dQ = gQ.getData(n);
      
      for(auto di : gD) {
        auto& dD = gD.getData(di);
        
        if(dQ.label != dD.label) {
          continue;
        }
        
        // self loop for n but not for *di
        if(gQ.findEdge(n, n) != gQ.edge_end(n) && gD.findEdge(di, di) == gD.edge_end(di)) {
          continue;
        }
        
        dQ.candidate.push_back(di);
      }
      
      std::sort(dQ.candidate.begin(), dQ.candidate.end());
      assert(std::adjacent_find(dQ.candidate.begin(), dQ.candidate.end()) == dQ.candidate.end()); // no duplicates
      
      nodeEmpty.update(dQ.candidate.empty());
    }

    // return true if at least one node has an empty set of candidates
    static bool go(DGraph& gD, QGraph& gQ) {
      Galois::GReduceLogicalOR isSomeNodeEmpty;
      Galois::do_all_local(gQ, FilterCandidatesInternal(gD, gQ, isSomeNodeEmpty), Galois::loopname("filter"), Galois::do_all_steal<true>());
      return isSomeNodeEmpty.reduce();
    }
  };

  struct SubgraphSearchInternal {
    typedef int tt_does_not_need_aborts;
    typedef int tt_does_not_need_push;
    typedef int tt_needs_parallel_break;
    typedef int tt_does_not_need_stats;
    typedef int tt_needs_per_iter_alloc;
    
    DGraph& gD;
    QGraph& gQ;
    MatchingVector& report;
    SubgraphSearchInternal(DGraph& d, QGraph& q, MatchingVector& r): gD(d), gQ(q), report(r) {}

    struct LocalState {
      // query state
      std::set<QGNode, Galois::PerIterAllocTy::rebind<QGNode>::other> qFrontier;
      std::set<QGNode, Galois::PerIterAllocTy::rebind<QGNode>::other> qMatched;
      
      // data state
      std::set<DGNode, Galois::PerIterAllocTy::rebind<DGNode>::other> dFrontier;
      std::set<DGNode, Galois::PerIterAllocTy::rebind<DGNode>::other> dMatched;

      LocalState(Galois::PerIterAllocTy& a) :qFrontier(a), qMatched(a), dFrontier(a), dMatched(a) {}
      
      QGNode nextQueryNode(QGraph& gQ, Matching& matching) {
        if(qFrontier.size()) {
          return *(qFrontier.begin());
        } else {
          for(auto qi : gQ) {
            bool isMatched = false;
            for(auto& mi : matching) {
              if(qi == mi.nQ) {
                isMatched = true;
                break;
              }
            }
            if(!isMatched) {
              return qi;
            }
          }
        }
        //FIXME: ??
        abort();
      }
    };

    template<typename Graph, typename Set>
    void countInNeighbors(Graph& g, typename Graph::GraphNode n, Set& matched, Set& frontier, long int *numFrontier, long int *numOther) {
      for(auto ei : g.in_edges(n)) {
        auto ngh = g.getInEdgeDst(ei);
        if(frontier.count(ngh)) {
          *numFrontier += 1;
        } else { 
          *numOther += (1 - matched.count(ngh));
        }
      }
    }
    
    template<typename Graph, typename Set>
    void countNeighbors(Graph& g, typename Graph::GraphNode n, Set& matched, Set& frontier, long int *numFrontier, long int *numOther) {
      for(auto ei : g.edges(n)) {
        auto ngh = g.getEdgeDst(ei);
        if(frontier.count(ngh)) {
          *numFrontier += 1;
        } else {
          *numOther += (1 - matched.count(ngh));
        }
      }
    } 
    
    std::vector<DGNode, Galois::PerIterAllocTy::rebind<DGNode>::other> 
    refineCandidates(DGraph& gD, QGraph& gQ, QGNode nQuery, Galois::PerIterAllocTy& alloc, LocalState& state) {
      std::vector<DGNode, Galois::PerIterAllocTy::rebind<DGNode>::other> refined(alloc);
      auto numNghQ = std::distance(gQ.edge_begin(nQuery), gQ.edge_end(nQuery));
      long int numFrontierNghQ = 0, numOtherNghQ = 0;
      countNeighbors(gQ, nQuery, state.qMatched, state.qFrontier, &numFrontierNghQ, &numOtherNghQ);
      
      long int numInNghQ = 0, numFrontierInNghQ = 0, numOtherInNghQ = 0;
      if(!undirected) {
        numInNghQ = std::distance(gQ.in_edge_begin(nQuery), gQ.in_edge_end(nQuery));
        countInNeighbors(gQ, nQuery, state.qMatched, state.qFrontier, &numFrontierInNghQ, &numOtherInNghQ);
      }
      
      // consider all nodes in data frontier
      auto& dQ = gQ.getData(nQuery);
      for(auto ii : state.dFrontier) {
        // not a candidate for nQuery
        if(!std::binary_search(dQ.candidate.begin(), dQ.candidate.end(), ii)) {
          continue;
        }
        
        auto numNghD = std::distance(gD.edge_begin(ii), gD.edge_end(ii));
        if(numNghD < numNghQ) {
          continue;
        }
        
        long int numFrontierNghD = 0, numOtherNghD = 0;
        countNeighbors(gD, ii, state.dMatched, state.dFrontier, &numFrontierNghD, &numOtherNghD);
        if(numFrontierNghD < numFrontierNghQ) {
          continue;
        }
        if(numOtherNghD < numOtherNghQ) {
          continue;
        }
        
        if(undirected) {
          refined.push_back(ii);
          continue;
        }
        
        auto numInNghD = std::distance(gD.in_edge_begin(ii), gD.in_edge_end(ii));
        if(numInNghD < numInNghQ) {
          continue;
        }
        
        long int numFrontierInNghD = 0, numOtherInNghD = 0;    
        countInNeighbors(gD, ii, state.dMatched, state.dFrontier, &numFrontierInNghD, &numOtherInNghD);
        if(numFrontierInNghD < numFrontierInNghQ) {
          continue;
        }
        if(numOtherInNghD < numOtherInNghQ) {
          continue;
        }
        
        refined.push_back(ii);
      }
      return refined;
    }
    
    bool isJoinable(DGraph& gD, QGraph& gQ, DGNode nD, QGNode nQ, Matching& matching) {
      for(auto& mi : matching) {
        // nD is already matched
        if(nD == mi.nD) {
          return false;
        }
        
        // nQ => (mi->nQ) exists but not nD => (mi->nD)
        if(gQ.findEdge(nQ, mi.nQ) != gQ.edge_end(nQ) && gD.findEdge(nD, mi.nD) == gD.edge_end(nD)) {
          return false;
        }
        
        // (mi->nQ) => nQ exists but not (mi->nD) => nD
        // skip if both data and query graphs are directed
        if(!undirected) {
          if(gQ.findEdge(mi.nQ, nQ) != gQ.edge_end(mi.nQ) && gD.findEdge(mi.nD, nD) == gD.edge_end(mi.nD)) {
            return false;
          }
        }
      }
      
      return true;
    }
    
   template<typename StateSet, typename StepSet, typename Graph>
    void insertDstFrontier(StateSet& sMatched, StateSet& sFrontier, StepSet& sAdd2F, Graph& g, typename Graph::GraphNode n) {
      for(auto ei: g.edges(n)) {
        auto ngh = g.getEdgeDst(ei);
        if(!sMatched.count(ngh) && sFrontier.insert(ngh).second)
          sAdd2F.push_back(ngh);
      }
    }

    template<typename StateSet, typename StepSet, typename Graph>
    void insertInDstFrontier(StateSet& sMatched, StateSet& sFrontier, StepSet& sAdd2F, Graph& g, typename Graph::GraphNode n) {
      for(auto ei: g.in_edges(n)) {
        auto ngh = g.getInEdgeDst(ei);
        if(!sMatched.count(ngh) && sFrontier.insert(ngh).second)
          sAdd2F.push_back(ngh);
      }
    }

    void doSearch(LocalState& state, Matching& matching, Galois::PerIterAllocTy& alloc) {
      if(currentlyFound.load() >= kFound)
        return;

      if(matching.size() == gQ.size()) {
        report.push_back(matching);
        currentlyFound += 1;
        return;
      }

      auto nQ = state.nextQueryNode(gQ, matching);

      std::vector<DGNode, Galois::PerIterAllocTy::rebind<DGNode>::other> refined = refineCandidates(gD, gQ, nQ, alloc, state);

      // update query state
      state.qMatched.insert(nQ);
      state.qFrontier.erase(nQ);

      std::vector<QGNode, Galois::PerIterAllocTy::rebind<QGNode>::other> qAdd2Frontier(alloc);
      insertDstFrontier(state.qMatched, state.qFrontier, qAdd2Frontier, gQ, nQ);
      if(!undirected)
        insertInDstFrontier(state.qMatched, state.qFrontier, qAdd2Frontier, gQ, nQ);

      // search for all possible candidate data nodes
      for(auto& ri : refined) {
        if(!isJoinable(gD, gQ, ri, nQ, matching)) {
          continue;
        }

        // add (nQ, *ri) to matching 
        matching.push_back(NodeMatch(nQ, ri));

        // update data state
        state.dMatched.insert(ri);
        state.dFrontier.erase(ri);

        std::vector<DGNode, Galois::PerIterAllocTy::rebind<DGNode>::other> dAdd2Frontier(alloc);
        insertDstFrontier(state.dMatched, state.dFrontier, dAdd2Frontier, gD, ri);
        if (!undirected)
          insertInDstFrontier(state.dMatched, state.dFrontier, dAdd2Frontier, gD, ri);
        //state.dFrontierSize.update(state.dFrontier.size());

        doSearch(state, matching, alloc);
        if(currentlyFound.load() >= kFound) {
          return;
        }

        // restore data state
        state.dMatched.erase(ri);
        state.dFrontier.insert(ri);
        for(auto& ii : dAdd2Frontier) {
          state.dFrontier.erase(ii);
        }
        dAdd2Frontier.clear();
 
        // remove (nQ, *ri) from matching
        matching.pop_back();
      }

      // restore query state
      state.qMatched.erase(nQ);
      state.qFrontier.insert(nQ);
      for(auto ii : qAdd2Frontier) {
        state.qFrontier.erase(ii);
      }
    }

    template<typename Set, typename Graph>
    void insertDst(Set& s, Graph& g, typename Graph::GraphNode n) {
      for (auto ei : g.edges(n))
        s.insert(g.getEdgeDst(ei));
    }

    template<typename Set, typename Graph>
    void insertInDst(Set& s, Graph& g, typename Graph::GraphNode n) {
      for (auto ei : g.in_edges(n))
        s.insert(g.getInEdgeDst(ei));
    }
 
    // Galois::for_each expects ctx
    void operator()(NodeMatch& seed, Galois::UserContext<NodeMatch>& ctx) {
      LocalState state(ctx.getPerIterAlloc());

      auto nQ = seed.nQ;
      state.qMatched.insert(nQ);

      insertDst(state.qFrontier, gQ, nQ);
      if(!undirected)
        insertInDst(state.qFrontier, gQ, nQ);

      auto nD = seed.nD;
      state.dMatched.insert(nD);

      insertDst(state.dFrontier, gD, nD);
      if(!undirected)
        insertInDst(state.dFrontier, gD, nD);

      //      state.dFrontierSize.update(state.dFrontier.size());

      Matching matching{seed};
      doSearch(state, matching, ctx.getPerIterAlloc());

      if(currentlyFound.load() >= kFound) {
        ctx.breakLoop();
      }
    }
  };

public:
  // return true if at least one node has an empty set of candidates
  static bool filterCandidates(DGraph& gD, QGraph& gQ) {
    return FilterCandidatesInternal::go(gD, gQ);
  }

  static MatchingVector subgraphSearch(DGraph& gD, QGraph& gQ) {
    MatchingVector report;
    Galois::InsertBag<NodeMatch> works;
    
    // parallelize the search for candidates of gQ.begin()
    auto nQ = *(gQ.begin());
    for(auto& ci : gQ.getData(nQ).candidate)
      works.push_back(NodeMatch(nQ, ci));

    Galois::for_each_local(works, SubgraphSearchInternal(gD, gQ, report), Galois::loopname("search_for_each"));
//    std::cout << "max size for dFrontier is " << dFrontierSize.reduce() << std::endl; 
    return report;
  }
};

struct UllmannAlgo {
  std::string name() const { return "Ullmann"; }

  struct FilterCandidatesInternal {
    DGraph& gD;
    QGraph& gQ;
    Galois::GReduceLogicalOR& nodeEmpty;
    FilterCandidatesInternal(DGraph& d, QGraph& q, Galois::GReduceLogicalOR& lor): gD(d), gQ(q), nodeEmpty(lor) {}

    void operator()(const QGNode n) const {
      auto& dQ = gQ.getData(n);

      for(auto di = gD.begin(), de = gD.end(); di != de; ++di) {
        auto& dD = gD.getData(*di);

        if(dQ.label != dD.label) {
          continue;
        }

        // self loop for n but not for *di
        if(gQ.findEdge(n, n) != gQ.edge_end(n) && gD.findEdge(*di, *di) == gD.edge_end(*di)) {
          continue;
        }

        dQ.candidate.push_back(*di);
      }

      nodeEmpty.update(dQ.candidate.empty());
    }
  };

  struct SubgraphSearchInternal {
    typedef int tt_does_not_need_aborts;
    typedef int tt_does_not_need_push;
    typedef int tt_needs_parallel_break;
    typedef int tt_does_not_need_stats;

    DGraph& gD;
    QGraph& gQ;
    MatchingVector& report;
    SubgraphSearchInternal(DGraph& d, QGraph& q, MatchingVector& r): gD(d), gQ(q), report(r) {}

    QGNode nextQueryNode(QGraph& gQ, Matching& matching) {
      auto qi = gQ.begin();
      std::advance(qi, matching.size());
      return *qi;
    }

    void refineCandidates(DGraph& gD, QGraph& gQ, QGNode nQuery, Matching& matching, std::vector<DGNode>& refined) {
      auto& dQ = gQ.getData(nQuery);
      auto numNghQ = std::distance(gQ.edge_begin(nQuery), gQ.edge_end(nQuery));
      auto numInNghQ = std::distance(gQ.in_edge_begin(nQuery), gQ.in_edge_end(nQuery));

      for(auto ii = dQ.candidate.begin(), ie = dQ.candidate.end(); ii != ie; ++ii) {
        auto numNghD = std::distance(gD.edge_begin(*ii), gD.edge_end(*ii));
        auto numInNghD = std::distance(gD.in_edge_begin(*ii), gD.in_edge_end(*ii));

        if(numNghD >= numNghQ && numInNghD >= numInNghQ) {
          refined.push_back(*ii);
        }
      }
    }

    bool isJoinable(DGraph& gD, QGraph& gQ, DGNode nD, QGNode nQ, Matching& matching) {
      for(auto mi = matching.begin(), me = matching.end(); mi != me; ++mi) {
        // nD is already matched
        if(nD == mi->nD) {
          return false;
        }

        // nQ => (mi->nQ) exists but not nD => (mi->nD)
        if(gQ.findEdge(nQ, mi->nQ) != gQ.edge_end(nQ) && gD.findEdge(nD, mi->nD) == gD.edge_end(nD)) {
          return false;
        }

        // (mi->nQ) => nQ exists but not (mi->nD) => nD
        // skip if both data and query graphs are directed
        if(!undirected) {
          if(gQ.findEdge(mi->nQ, nQ) != gQ.edge_end(mi->nQ) && gD.findEdge(mi->nD, nD) == gD.edge_end(mi->nD)) {
            return false;
          }
        }
      }

      return true;
    }

    void doSearch(Matching& matching) {
      if(currentlyFound.load() >= kFound) {
          return;
      }

      if(matching.size() == gQ.size()) {
        report.push_back(matching);
        currentlyFound += 1;
        return;
      }

      auto nQ = nextQueryNode(gQ, matching);

      std::vector<DGNode> refined;
      refineCandidates(gD, gQ, nQ, matching, refined);

      for(auto ri = refined.begin(), re = refined.end(); ri != re; ++ri) {
        if(!isJoinable(gD, gQ, *ri, nQ, matching)) {
          continue;
        }

        // add (nQ, *ri) to matching 
        matching.push_back(NodeMatch(nQ, *ri));

        doSearch(matching);
        if(currentlyFound.load() >= kFound) {
          return;
        }

        // remove (nQ, *ri) from matching
        matching.pop_back();
      }
    }

    // Galois::for_each expects ctx
    void operator()(NodeMatch& seed, Galois::UserContext<NodeMatch>& ctx) {
      Matching matching{seed};
      doSearch(matching);
      if(currentlyFound.load() >= kFound) {
        ctx.breakLoop();
      }
    }
  };

public:
  // return true if at least one node has an empty set of candidates
  static bool filterCandidates(DGraph& gD, QGraph& gQ) {
    Galois::GReduceLogicalOR isSomeNodeEmpty;
    Galois::do_all_local(gQ, FilterCandidatesInternal(gD, gQ, isSomeNodeEmpty), Galois::loopname("filter"), Galois::do_all_steal<true>());
    return isSomeNodeEmpty.reduce();
  }

  static MatchingVector subgraphSearch(DGraph& gD, QGraph& gQ) {
    MatchingVector report;
    Galois::InsertBag<NodeMatch> works;

    // parallelize the search for candidates of gQ.begin()
    auto nQ = *(gQ.begin());
    auto& dQ = gQ.getData(nQ);
    for(auto ci = dQ.candidate.begin(), ce = dQ.candidate.end(); ci != ce; ++ci) {
      works.push_back(NodeMatch(nQ, *ci));
    }

    Galois::for_each_local(works, SubgraphSearchInternal(gD, gQ, report), Galois::loopname("search_for_each"));
    return report;
  }
};

// check if the first matching is correct
void verifyMatching(Matching& matching, DGraph& gD, QGraph& gQ) {
  bool isFailed = false;

  for(auto m1 = matching.begin(), me = matching.end(); m1 != me; ++m1) {
    auto& dQ1 = gQ.getData(m1->nQ);
    auto& dD1 = gD.getData(m1->nD);

    if(dQ1.label != dD1.label) {
      isFailed = true;
      std::cerr << "label not match: gQ(" << dQ1.id << ") = " << dQ1.label;
      std::cerr << ", gD(" << dD1.id << ") = " << dD1.label << std::endl;
    }

    for(auto m2 = matching.begin(); m2 != me; ++m2) {
      auto& dQ2 = gQ.getData(m2->nQ);
      auto& dD2 = gD.getData(m2->nD);

      // two distinct query nodes map to the same data node
      if(m1->nQ != m2->nQ && m1->nD == m2->nD) {
        isFailed = true;
        std::cerr << "inconsistent mapping to data node: gQ(" << dQ1.id;
        std::cerr << ") to gD(" << dD1.id << "), gQ(" << dQ2.id;
        std::cerr << ") to gD(" << dD2.id << ")" << std::endl;
      }

      // a query node mapped to different data nodes
      if(m1->nQ == m2->nQ && m1->nD != m2->nD) {
        isFailed = true;
        std::cerr << "inconsistent mapping from query node: gQ(" << dQ1.id;
        std::cerr << ") to gD(" << dD1.id << "), gQ(" << dQ2.id;
        std::cerr << ") to gD(" << dD2.id << ")" << std::endl;
      }

      // query edge not matched to data edge
      if(gQ.findEdge(m1->nQ, m2->nQ) != gQ.edge_end(m1->nQ) && gD.findEdge(m1->nD, m2->nD) == gD.edge_end(m1->nD)) {
        isFailed = true;
        std::cerr << "edge not match: gQ(" << dQ1.id << " => " << dQ2.id;
        std::cerr << "), but no gD(" << dD1.id << " => " << dD2.id << ")" << std::endl;
      }
    }
  }

  if(isFailed) {
    GALOIS_DIE("Verification failed");
  } else {
    std::cout << "Verification succeeded" << std::endl;
  }
}

void reportMatchings(MatchingVector& report, DGraph& gD, QGraph& gQ) {
  auto output = std::ofstream("report.txt");
  auto ri = report.begin(), re = report.end();
  unsigned int i = 0; 
  while(ri != re) {
    output << i << ": { ";
    for(auto mi = ri->begin(), me = ri->end(); mi != me; ++mi) {
      output << "(" << gQ.getData(mi->nQ).id << ", " << gD.getData(mi->nD).id << ") ";
    }
    output << "}" << std::endl;
    ++ri;
    ++i;
  } 
  output.close();
}

template<typename Algo>
void run() {
  DGraph gD;
  if(graphD.size()) {
    Galois::Graph::readGraph(gD, graphD);
    std::cout << "Reading data graph..." << std::endl;
  } else {
    GALOIS_DIE("Failed to read data graph");
  }
  if(rndSeedDByTime) {
    rndSeedD = std::chrono::system_clock::now().time_since_epoch().count();
  }
  std::cout << "rndSeedD: " << rndSeedD << std::endl;
  initializeGraph(gD, rndSeedD);
  std::cout << "data graph initialized" << std::endl;
//  printGraph(gD);

  QGraph gQ;
  if(graphQ.size()) {
    Galois::Graph::readGraph(gQ, graphQ);
    std::cout << "Reading query graph..." << std::endl;
  } else {
    GALOIS_DIE("Failed to read query graph");
  }
  if(rndSeedQByTime) {
    rndSeedQ = std::chrono::system_clock::now().time_since_epoch().count();
  }
  std::cout << "rndSeedQ: " << rndSeedQ << std::endl;
  initializeGraph(gQ, rndSeedQ);
  std::cout << "query graph initialized" << std::endl;
//  printGraph(gQ);

  Algo algo;
  std::cout << "Running " << algo.name() << " Algorithm..." << std::endl;

  Galois::StatTimer T;
  T.start();

  Galois::StatTimer filterT("FilterCandidates");
  filterT.start();
  bool isSomeNodeUnmatched = algo.filterCandidates(gD, gQ);
  filterT.stop();

  if(isSomeNodeUnmatched) {
    T.stop();
    std::cout << "Some nodes have no candidates to match." << std::endl;
    return;
  }

  Galois::StatTimer searchT("SubgraphSearch");
  searchT.start();
  currentlyFound.store(0);
  MatchingVector report = algo.subgraphSearch(gD, gQ);
  searchT.stop();

  T.stop();
  std::cout << "Found " << currentlyFound << " instance(s) of the query graph." << std::endl;
  if(currentlyFound) {
    reportMatchings(report, gD, gQ);
    verifyMatching(*(report.begin()), gD, gQ);
  }
}

int main(int argc, char **argv) {
  Galois::StatManager statManager;
  LonestarStart(argc, argv, name, desc, url);

  Galois::StatTimer T("TotalTime");
  T.start();
  switch (algo) {
    case Algo::ullmann: run<UllmannAlgo>(); break;
    case Algo::vf2: run<VF2Algo>(); break;
    default: std::cerr << "Unknown algorithm\n"; abort();
  }
  T.stop();

  return 0;
}

