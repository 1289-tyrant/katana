/** Subgraph isomorphism -*- C++ -*-
 * @file
 * @section License
 *
 * Galois, a framework to exploit amorphous data-parallelism in irregular
 * programs.
 *
 * Copyright (C) 2013, The University of Texas at Austin. All rights reserved.
 * UNIVERSITY EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES CONCERNING THIS
 * SOFTWARE AND DOCUMENTATION, INCLUDING ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR ANY PARTICULAR PURPOSE, NON-INFRINGEMENT AND WARRANTIES OF
 * PERFORMANCE, AND ANY WARRANTY THAT MIGHT OTHERWISE ARISE FROM COURSE OF
 * DEALING OR USAGE OF TRADE.  NO WARRANTY IS EITHER EXPRESS OR IMPLIED WITH
 * RESPECT TO THE USE OF THE SOFTWARE OR DOCUMENTATION. Under no circumstances
 * shall University be liable for incidental, special, indirect, direct or
 * consequential damages or loss of profits, interruption of business, or
 * related expenses which may arise from use of Software or Documentation,
 * including but not limited to those resulting from defects in Software and/or
 * Documentation, or loss or inaccuracy of data of any kind.
 *
 * @section Description
 *
 * Subgraph isomorphism.
 *
 * @author Yi-Shan Lu <yishanlu@cs.utexas.edu>
 */
#include "Galois/Galois.h"
#include "Galois/Bag.h"
#include "Galois/Statistic.h"
#include "Galois/Timer.h"
#include "Galois/Graphs/Graph.h"
#include "Galois/Graphs/TypeTraits.h"
#include "llvm/Support/CommandLine.h"
#include "Lonestar/BoilerPlate.h"
#include "Galois/Accumulator.h"

#include <iostream>
#include <vector>
#include <string>
#include <atomic>

#include <chrono>
#include <random>

namespace cll = llvm::cl;

static const char* name = "Subgraph Isomorphism";
static const char* desc =
  "Computes up to k isomorphism on data graph for each query graph";
static const char* url = "subgraph_isomorphism";

unsigned int pattern_found;

enum Algo {
  ullmann
};

static cll::opt<bool> rndSeedByTime("rndSeedByTime", cll::desc("rndSeed generated by system time"), cll::init(false));
static cll::opt<unsigned int> rndSeed("rndSeed", cll::desc("random seed"), cll::init(0));
static cll::opt<unsigned int> kFound("kFound", cll::desc("stop when k instances found"), cll::init(10));

static cll::opt<bool> constructD("constructData", cll::desc("construct a data graph"), cll::init(true));
static cll::opt<unsigned int> numNodesD("numDataNodes", cll::desc("# data nodes"), cll::init(9));
static cll::opt<unsigned int> numEdgesD("numDataEdges", cll::desc("# data edges"), cll::init(20));

static cll::opt<bool> constructQ("constructQuery", cll::desc("construct a query graph"), cll::init(true));
static cll::opt<unsigned int> numNodesQ("numQueryNodes", cll::desc("# query nodes"), cll::init(2));
static cll::opt<unsigned int> numEdgesQ("numQueryEdges", cll::desc("# query edges"), cll::init(1));

static cll::opt<unsigned int> numLabels("numLabels", cll::desc("# labels"), cll::init(2));

static cll::opt<Algo> algo("algo", cll::desc("Choose an algorithm:"),
    cll::values(
      clEnumValN(Algo::ullmann, "ullmann", "Ullmann"),
      clEnumValEnd), cll::init(Algo::ullmann));

struct DNode {
  char label;
  unsigned int id;
};

typedef Galois::Graph::FirstGraph<DNode, void, true> DGraph; // directed graph with DNode nodes and typeless edges
typedef DGraph::GraphNode DGNode;

struct QNode {
  char label;
  unsigned int id;
  std::vector<DGNode> candidate;
};

typedef Galois::Graph::FirstGraph<QNode, void, true> QGraph;
typedef QGraph::GraphNode QGNode;

struct NodeMatch {
  QGNode nQ;
  DGNode nD;
  NodeMatch(const QGNode q, const DGNode d): nQ(q), nD(d) {}
  NodeMatch(): nQ(), nD() {}
};

typedef std::vector<NodeMatch> Matching;
typedef Galois::InsertBag<Matching> MatchingVector;

static std::minstd_rand0 generator;
static std::uniform_int_distribution<unsigned> distribution;

static std::atomic_uint currentlyFound;

template<typename Graph>
void constructGraph(Graph& g, int numNodes, int numEdges) {
  typedef typename Graph::GraphNode GNode;
  typedef typename Graph::node_data_type Node;

  // construct a set of nodes
  std::vector<GNode> nodes(numNodes);
  for(int i = 0; i < numNodes; ++i) {
    GNode n = g.createNode();
    g.addNode(n);
    Node& data = g.getData(n);
    data.label = 'A' + distribution(generator) % numLabels;
    data.id = i;
    nodes[i] = n;
  }

  // add edges
  for(int i = 0; i < numEdges; ) {
    unsigned int src = distribution(generator) % numNodes;
    unsigned int dst = distribution(generator) % numNodes;

    // no self loops and repeated edges
    if(src != dst && g.findEdge(nodes[src], nodes[dst]) == g.edge_end(nodes[src])) {
      g.addEdge(nodes[src], nodes[dst]);
      ++i;
    }
  }
}

template<typename Graph>
void printGraph(Graph& g) {
  for(auto ni = g.begin(), ne = g.end(); ni != ne; ++ni) {
    auto& data = g.getData(*ni);
    std::cout << "node " << data.id << ": " << data.label << std::endl;
    for(auto ei = g.edge_begin(*ni), ee = g.edge_end(*ni); ei != ee; ++ei) {
      auto& dstData = g.getData(g.getEdgeDst(ei));
      std::cout << "  edge to node " << dstData.id << std::endl;
    }
  }
  std::cout << std::endl;
}

struct UllmannAlgo {
  std::string name() const { return "Ullmann"; }

  struct FilterCandidatesInternal {
    DGraph& gD;
    QGraph& gQ;
    Galois::GReduceLogicalOR& nodeEmpty;
    FilterCandidatesInternal(DGraph& d, QGraph& q, Galois::GReduceLogicalOR& lor): gD(d), gQ(q), nodeEmpty(lor) {}

    void operator()(const QGNode& n) const {
      auto& dQ = gQ.getData(n);

      for(auto di = gD.begin(), de = gD.end(); di != de; ++di) {
        auto& dD = gD.getData(*di);

        if(dQ.label == dD.label) {
          dQ.candidate.push_back(*di);
        }
      }

      nodeEmpty.update(dQ.candidate.empty());
    }
  };

  // return true if at least one node has an empty set of candidates
  bool filterCandidates(DGraph& gD, QGraph& gQ) {
    Galois::GReduceLogicalOR isSomeNodeEmpty;
    Galois::do_all_local(gQ, FilterCandidatesInternal(gD, gQ, isSomeNodeEmpty), Galois::loopname("filter"));
    return isSomeNodeEmpty.reduce();
  }

  QGraph::iterator nextQueryNode(QGraph& gQ, Matching& matching) {
    auto qi = gQ.begin();
    std::advance(qi, matching.size());
    return qi;
  }

  void refineCandidates(DGraph& gD, QGraph& gQ, QGNode nQuery, Matching& matching, std::vector<DGNode>& refined) {
    auto& dQ = gQ.getData(nQuery);
    auto numNghQ = std::distance(gQ.edge_begin(nQuery), gQ.edge_end(nQuery));

    for(auto ii = dQ.candidate.begin(), ie = dQ.candidate.end(); ii != ie; ++ii) {
      auto numNghD = std::distance(gD.edge_begin(*ii), gD.edge_end(*ii));

      if(numNghD >= numNghQ) {
        refined.push_back(*ii);
      }
    }
  }

  bool isJoinable(DGraph& gD, QGraph& gQ, DGNode nD, QGNode nQ, Matching& matching) {
    for(auto mi = matching.begin(), me = matching.end(); mi != me; ++mi) {
      // nD is already matched
      if(nD == mi->nD) {
        return false;
      }

      // nQ => (mi->nQ) exists but not nD => (mi->nD)
      if(gQ.findEdge(nQ, mi->nQ) != gQ.edge_end(nQ) && gD.findEdge(nD, mi->nD) == gD.edge_end(nD)) {
        return false;
      }

      // (mi->nQ) => nQ exists but not (mi->nD) => nD
      if(gQ.findEdge(mi->nQ, nQ) != gQ.edge_end(mi->nQ) && gD.findEdge(mi->nD, nD) == gD.edge_end(mi->nD)) {
        return false;
      }
    }

    return true;
  }

  struct SubgraphSearchInternal {
    typedef int tt_does_not_need_aborts;
    typedef int tt_does_not_need_push;
    typedef int tt_needs_parallel_break;

    DGraph& gD;
    QGraph& gQ;
    MatchingVector& report;
    UllmannAlgo *algo;
    SubgraphSearchInternal(DGraph& d, QGraph& q, MatchingVector& r, UllmannAlgo *algo): gD(d), gQ(q), report(r), algo(algo) {}

    void doSearch(Matching& matching) {
      if(currentlyFound.load() >= kFound) {
          return;
      }

      if(matching.size() == gQ.size()) {
        report.push_back(matching);
        currentlyFound += 1;
        return;
      }

      auto qi = algo->nextQueryNode(gQ, matching);

      std::vector<DGNode> refined;
      algo->refineCandidates(gD, gQ, *qi, matching, refined);

      for(auto ri = refined.begin(), re = refined.end(); ri != re; ++ri) {
        if(!algo->isJoinable(gD, gQ, *ri, *qi, matching)) {
          continue;
        }

        // add (*qi, *ri) to matching 
        matching.push_back(NodeMatch(*qi, *ri));

        doSearch(matching);
        if(currentlyFound.load() >= kFound) {
          return;
        }

        // remove (*qi, *ri) from matching
        matching.pop_back();
      }
    }

    // Galois::for_each expects cxt
    void operator()(Matching& matching, Galois::UserContext<Matching>& cxt) {
      doSearch(matching);
      if(currentlyFound >= kFound) {
        cxt.breakLoop();
      }
    }
  };

  void subgraphSearch(DGraph& gD, QGraph& gQ, MatchingVector& report) {
    MatchingVector works;
    Matching matching;

    // paralleize the search for candidates of gQ.begin()
    auto nQ = *(gQ.begin());
    auto& dQ = gQ.getData(nQ);
    for(auto ci = dQ.candidate.begin(), ce = dQ.candidate.end(); ci != ce; ++ci) {
      matching.push_back(NodeMatch(nQ, *ci));
      works.push_back(matching);
      matching.pop_back();
    }

    Galois::for_each_local(works, SubgraphSearchInternal(gD, gQ, report, this), Galois::loopname("search"));
  }
};

// check if the first matching is correct
void verifyMatching(Matching& matching, DGraph& gD, QGraph& gQ) {
  bool isFailed = false;

  for(auto m1 = matching.begin(), me = matching.end(); m1 != me; ++m1) {
    auto& dQ1 = gQ.getData(m1->nQ);
    auto& dD1 = gD.getData(m1->nD);

    if(dQ1.label != dD1.label) {
      isFailed = true;
      std::cout << "label not match: gQ(" << dQ1.id << ") = " << dQ1.label;
      std::cout << ", gD(" << dD1.id << ") = " << dD1.label << std::endl;
    }

    for(auto m2 = matching.begin(); m2 != me; ++m2) {
      auto& dQ2 = gQ.getData(m2->nQ);
      auto& dD2 = gD.getData(m2->nD);

      if(dQ1.id < dQ2.id && m1->nQ != m2->nQ && m1->nD == m2->nD) {
        isFailed = true;
        std::cout << "multiple matches for a node: gQ(" << dQ1.id;
        std::cout << ") to gD(" << dD1.id << "), gQ(" << dQ2.id;
        std::cout << ") to gD(" << dD2.id << ")" << std::endl;
      }

      if(gQ.findEdge(m1->nQ, m2->nQ) == gQ.edge_end(m1->nQ)) {
        continue;
      }

      if(gD.findEdge(m1->nD, m2->nD) == gD.edge_end(m1->nD)) {
        isFailed = true;
        std::cout << "edge not match: gQ(" << dQ1.id << " => " << dQ2.id;
        std::cout << "), but no gD(" << dD1.id << " => " << dD2.id << ")" << std::endl;
      }
    }
  }

  if(isFailed) {
    GALOIS_DIE("Verification failed");
  } else {
    std::cout << "Verification succedded" << std::endl;
  }
}

void reportMatchings(MatchingVector& report, DGraph& gD, QGraph& gQ) {
  auto ri = report.begin(), re = report.end();
  unsigned int i = 0; 
  while(ri != re) {
    std::cout << i << ": { ";
    for(auto mi = ri->begin(), me = ri->end(); mi != me; ++mi) {
      std::cout << "(" << gQ.getData(mi->nQ).id << ", " << gD.getData(mi->nD).id << ") ";
    }
    std::cout << "}" << std::endl;
    ++ri;
    ++i;
  } 
}

template<typename Algo>
void run() {
  DGraph gD;
  if(constructD) {
    std::cout << "generating data graph..." << std::endl;
    constructGraph(gD, numNodesD, numEdgesD);
    printGraph(gD);
  }

  QGraph gQ;
  if(constructQ) {
    std::cout << "generating query graph..." << std::endl;
    constructGraph(gQ, numNodesQ, numEdgesQ);
    printGraph(gQ);
  }

  Algo algo;
  Galois::StatTimer T;
  T.start();

  Galois::StatTimer filterT("FilterCandidates");
  filterT.start();
  bool isSomeNodeUnmatched = algo.filterCandidates(gD, gQ);
  filterT.stop();

  if(isSomeNodeUnmatched) {
    T.stop();
    std::cout << "Some nodes have no candidates to match." << std::endl;
    return;
  }

  Galois::StatTimer searchT("SubgraphSearch");
  searchT.start();
  MatchingVector report;
  currentlyFound.store(0);
  algo.subgraphSearch(gD, gQ, report);
  searchT.stop();

  T.stop();
  std::cout << "Found " << currentlyFound << " instance(s) of the query graph." << std::endl;
  if(currentlyFound) {
    reportMatchings(report, gD, gQ);
    verifyMatching(*(report.begin()), gD, gQ);
  }
}

int main(int argc, char **argv) {
  Galois::StatManager statManager;
  LonestarStart(argc, argv, name, desc, url);

  if(rndSeedByTime) {
    rndSeed = std::chrono::system_clock::now().time_since_epoch().count();
  }
  std::cout << "rndSeed: " << rndSeed << std::endl;
//  generator.seed(rndSeed); // FIXME: does not compile if uncomment

  Galois::StatTimer T("TotalTime");
  T.start();
  switch (algo) {
    case Algo::ullmann: run<UllmannAlgo>(); break;
    default: std::cerr << "Unknown algorithm\n"; abort();
  }
  T.stop();

  return 0;
}

