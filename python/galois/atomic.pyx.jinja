import galois.shmem

from .cpp.libgalois cimport atomic
from libc.stdint cimport uintptr_t, int64_t, uint64_t

__all__ = [
    "GAccumulator",
    "GReduceMax",
    "GReduceMin",
    "GReduceLogicalOr",
    "GReduceLogicalAnd"
    ]

{% import "numba_wrapper_support.pyx.jinja" as numba %}

{{numba.header()}}

{% macro wrap_reducible(name, element_type, underlying_type) %}
{% if not underlying_type -%}
{% set underlying_type %}atomic.{{name}}[{{element_type}}]{% endset -%}
{% set class_name %}{{name}}_{{element_type}}{% endset -%}
{% else -%}
{% set underlying_type %}atomic.{{underlying_type}}{% endset -%}
{% set class_name %}{{name}}{% endset -%}
{% endif -%}
cdef class {{class_name}}:
    cdef {{underlying_type}} underlying

    def update(self, {{element_type}} v):
        self.underlying.update(v)

    def reset(self):
        self.underlying.reset()

    def reduce(self):
        return self.underlying.reduce()

    def get_local(self):
        return self.underlying.getLocal()

    @property
    def address(self):
        return <uintptr_t>&self.underlying

{% call numba.class_(class_name, underlying_type) %}
{{numba.method("update", "void", [element_type])}}
{{numba.method("reset", "void", [])}}
{{numba.method("reduce", element_type, [])}}
{{numba.method("get_local", element_type, [], "getLocal")}}
{% endcall %}
{% endmacro %}

{% for reducible in ["GAccumulator", "GReduceMax", "GReduceMin"] %}
{{reducible}} = {}
{% for element_type, python_type in [("uint64_t", "'uint64_t'"), ("int64_t", "int"), ("double", "float")] %}
{{wrap_reducible(reducible, element_type, None)}}
{{reducible}}[{{python_type}}] = {{reducible}}_{{element_type}}
{% endfor %}
{% endfor %}

{% for reducible in ["GReduceLogicalAnd", "GReduceLogicalOr"] %}
{{wrap_reducible(reducible, "bint", reducible)}}
{% endfor %}

{{numba.register_all_wrappers()}}