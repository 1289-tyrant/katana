# -*- mode: cython -*-
{% set instantiation_types = [("uint64_t", "np.uint64"), ("int64_t", "int"), ("double", "float")] %}
"""
This module contains data structures designed for use with Galois' parallel loops.
They are instantiated for several element types, but cannot support custom element types.

The instantiations are:

{% for c, py in instantiation_types %}
* `{{py}}` (with C element type {{c}})
{% endfor %}

The instantiation is selected by indexing the type, for example `InsertBag[int]` or `LargeArray[np.uint64]`.
"""
import numpy as np
from galois.util.template_type import make_template_type1
from .cpp.libgalois cimport datastructures
from libc.stdint cimport uintptr_t, int64_t, uint64_t
from cython.operator cimport preincrement, dereference as deref
import cython

__all__ = ["InsertBag", "LargeArray"]

{% import "numba_wrapper_support.pyx.jinja" as numba %}

{{numba.header()}}

{% macro wrap_insert_bag(element_type) %}
{% set underlying_type %}datastructures.InsertBag[{{element_type}}]{% endset -%}
{% set class_name %}InsertBag_{{element_type}}{% endset -%}
@cython.freelist(2)
cdef class {{class_name}}_Iterator:
    def __next__(self):
        if self.it == self.end:
            raise StopIteration()
        v = <{{element_type}}>deref(self.it)
        preincrement(self.it)
        return v

cdef class {{class_name}}:
    """
    Unordered collection of elements. This data structure supports scalable
    concurrent pushes but reading the bag can only be done serially.
    """
    def push(self, {{element_type}} v):
        """
        Add an element to the collection. This may be called from numba compiled code.
        """
        self.underlying.push(v)

    def clear(self):
        """
        Discard the contents of this collection. Must be called from single threaded code.
        """
        self.underlying.clear()

    def empty(self):
        """
        Return true of the collection is empty.
        """
        return self.underlying.empty()

    def swap(self, {{class_name}} other):
        """
        Swap the contents of this collection with another efficiently. Must be called from single threaded code.
        """
        self.underlying.swap(other.underlying)

    def __iter__(self):
        """
        Iterate over the elements of the collection. Must be called from single threaded code.
        """
        i =  <{{class_name}}_Iterator>{{class_name}}_Iterator.__new__({{class_name}}_Iterator)
        i.obj = self
        i.it = self.underlying.begin()
        i.end = self.underlying.end()
        return i

    @property
    def address(self):
        return <uintptr_t>&self.underlying

{% call numba.class_(class_name, underlying_type) %}
{{numba.method("push", "void", [element_type])}}
{{numba.method("clear", "void", [])}}
{{numba.method("empty", "bint", [])}}
{% endcall %}
{% endmacro %}

_InsertBag_types = {}
{% for element_type, python_type in instantiation_types %}
{{wrap_insert_bag(element_type)}}
_InsertBag_types[{{python_type}}] = InsertBag_{{element_type}}
{% endfor %}
InsertBag = make_template_type1("InsertBag", _InsertBag_types)


{% macro wrap_large_array(element_type) %}
{% set underlying_type %}datastructures.LargeArray[{{element_type}}]{% endset -%}
{% set class_name %}LargeArray_{{element_type}}{% endset -%}
@cython.freelist(2)
cdef class {{class_name}}_Iterator:
    def __next__(self):
        if self.it == self.end:
            raise StopIteration()
        v = <{{element_type}}>deref(self.it)
        preincrement(self.it)
        return v

cdef class {{class_name}}:
    """
    An array of elements of the same type that are allocated using NUMA aware policies.

    The underlying array must be allocated with `allocateBlocked` or `allocateInterleaved`.
    """
    def __setitem__(self, uint64_t i, {{element_type}} v):
        """
        `self[i] = v`

        Set an element of the array. This may be called from numba code and is not bounds check in that context.
        """
        if i < 0 or i >= self.underlying.size():
            raise IndexError(i)
        self.underlying.set(i, v)

    def __getitem__(self, uint64_t i):
        """
        self[i]

        Get an element of the array. This may be called from numba code and is not bounds check in that context.
        """
        if i < 0 or i >= self.underlying.size():
            raise IndexError(i)
        return self.underlying[i]

    def __len__(self):
        """
        len(self)

        Get the size of the array. This may be called from numba code.
        """
        return self.underlying.size()

    def allocateInterleaved(self, uint64_t size):
        """
        allocateInterleaved(self, size)

        Allocate the array with a specific `size` using a NUMA interleaved memory policy.
        """
        self.underlying.allocateInterleaved(size)

    def allocateBlocked(self, uint64_t size):
        """
        allocateBlocked(self, size)

        Allocate the array with a specific `size` using blocked memory policy.
        """
        self.underlying.allocateBlocked(size)

    def __iter__(self):
        """
        iter(self)

        >>> for v in self: ...

        Iterate over the elements of the collection. This may be called from numba code.
        """
        i =  <{{class_name}}_Iterator>{{class_name}}_Iterator.__new__({{class_name}}_Iterator)
        i.obj = self
        i.it = self.underlying.begin()
        i.end = self.underlying.end()
        return i

    @property
    def address(self):
        return <uintptr_t>&self.underlying

{% call numba.class_(class_name, underlying_type) %}
{% call numba.method_with_body("get", element_type, ["uint64_t"]) %}
    return self[0][arg1]
{% endcall %}
{{numba.method("set", "void", ["uint64_t", element_type])}}
{{numba.method("data", element_type + "*", [])}}
{% endcall %}
{% endmacro %}

_LargeArray_types = {}
{% for element_type, python_type in instantiation_types %}
{{wrap_large_array(element_type)}}
_LargeArray_types[{{python_type}}] = LargeArray_{{element_type}}
{% endfor %}
LargeArray = make_template_type1("LargeArray", _LargeArray_types)

{{numba.register_all_wrappers()}}
