# -*- mode: cython -*-
from enum import Enum

{% set instantiation_types = [("uint64_t", "np.uint64", "Q"), ("int64_t", "int", "q"), ("double", "float", "d")] %}

"""
This module contains data structures designed for use with Galois' parallel loops.
They are instantiated for several element types, but cannot support custom element types.

The instantiations are:

{% for c, py, format in instantiation_types %}
* `{{py}}` (with C element type {{c}})
{% endfor %}

The instantiation is selected by indexing the type, for example `InsertBag[int]` or `LargeArray[np.uint64]`.
"""
import numpy as np
from galois.util.template_type import make_template_type1
from .cpp.libgalois cimport datastructures
from libc.stdint cimport uintptr_t, int64_t, uint64_t
from cython.operator cimport preincrement, dereference as deref
import cython

__all__ = ["InsertBag", "LargeArray", "AllocationPolicy"]

{% import "numba_wrapper_support.pyx.jinja" as numba %}

{{numba.header()}}

{% macro wrap_insert_bag(element_type) %}
{% set underlying_type %}datastructures.InsertBag[{{element_type}}]{% endset -%}
{% set class_name %}InsertBag_{{element_type}}{% endset -%}
@cython.freelist(2)
cdef class {{class_name}}_Iterator:
    def __next__(self):
        if self.it == self.end:
            raise StopIteration()
        v = <{{element_type}}>deref(self.it)
        preincrement(self.it)
        return v

cdef class {{class_name}}:
    """
    Unordered collection of elements. This data structure supports scalable
    concurrent pushes but reading the bag can only be done serially.
    """
    def push(self, {{element_type}} v):
        """
        push(self, v)

        Add an element to the collection. This may be called from numba compiled code.
        """
        self.underlying.push(v)

    def clear(self):
        """
        clear(self)

        Discard the contents of this collection. Must be called from single threaded code.
        """
        self.underlying.clear()

    def empty(self):
        """
        empty(self)

        Return true of the collection is empty.
        """
        return self.underlying.empty()

    def swap(self, {{class_name}} other):
        """
        swap(self, InsertBag other)

        Swap the contents of this collection with another efficiently. Must be called from single threaded code.
        """
        self.underlying.swap(other.underlying)

    def __iter__(self):
        """
        iter(self)

        Iterate over the elements of the collection. Must be called from single threaded code.
        """
        i =  <{{class_name}}_Iterator>{{class_name}}_Iterator.__new__({{class_name}}_Iterator)
        i.obj = self
        i.it = self.underlying.begin()
        i.end = self.underlying.end()
        return i

    @property
    def address(self):
        return <uintptr_t>&self.underlying

{% call numba.class_(class_name, underlying_type) %}
{{numba.method("push", "void", [element_type])}}
{{numba.method("clear", "void", [])}}
{{numba.method("empty", "bint", [])}}
{% endcall %}
{% endmacro %}

_InsertBag_types = {}
{% for element_type, python_type, buffer_format in instantiation_types %}
{{wrap_insert_bag(element_type)}}
_InsertBag_types[{{python_type}}] = InsertBag_{{element_type}}
{% endfor %}
InsertBag = make_template_type1("InsertBag", _InsertBag_types)


class AllocationPolicy(Enum):
    """
    NUMA allocation policies.
    """
    BLOCKED = 0
    INTERLEAVED = 1


{% macro wrap_large_array(element_type, python_type, buffer_format) %}
{% set underlying_type %}datastructures.LargeArray[{{element_type}}]{% endset -%}
{% set class_name %}LargeArray_{{element_type}}{% endset -%}
@cython.freelist(2)
cdef class {{class_name}}_Iterator:
    def __next__(self):
        if self.it == self.end:
            raise StopIteration()
        v = <{{element_type}}>deref(self.it)
        preincrement(self.it)
        return v

cdef class {{class_name}}:
    """
    An array of elements of the same type that are allocated using NUMA aware policies.
    """
    def __init__(self, size=None, policy=None):
        """
        __init__(self, size=None, policy=None)

        Construct a new array.

        If `size` and `policy` are provided, the array is allocated with the specified size and policy.
        Otherwise,  the underlying array must be allocated with `allocateBlocked` or `allocateInterleaved` after
        construction.
        """
        self.shape = -1
        self.stride = sizeof({{element_type}})
        if size is not None:
            if policy is None:
                raise ValueError("Policy must be provided to allocate.")
            if policy == AllocationPolicy.BLOCKED:
                self.allocateBlocked(size)
            elif policy == AllocationPolicy.INTERLEAVED:
                self.allocateInterleaved(size)
            else:
                raise TypeError("Policy must be an AllocationPolicy")

    def __setitem__(self, uint64_t i, {{element_type}} v):
        """
        `self[i] = v`

        Set an element of the array. This may be called from numba code and is not bounds check in that context.
        """
        if i < 0 or i >= self.underlying.size():
            raise IndexError(i)
        self.underlying.set(i, v)

    def __getitem__(self, uint64_t i):
        """
        self[i]

        Get an element of the array. This may be called from numba code and is not bounds check in that context.
        """
        if i < 0 or i >= self.underlying.size():
            raise IndexError(i)
        return self.underlying[i]

    def __len__(self):
        """
        len(self)

        Get the size of the array. This may be called from numba code.
        """
        return self.underlying.size()

    cdef bint _check_not_allocated(self) except False:
        if self.shape >= 0:
            raise ValueError("LargeArray is already allocated.")
        return True

    cdef bint _check_allocated(self) except False:
        if self.shape < 0:
            raise ValueError("LargeArray is not yet allocated.")
        return True

    cdef bint _mark_allocated(self) except False:
        self.shape = <Py_ssize_t>self.underlying.size()
        return True

    def allocateInterleaved(self, uint64_t size):
        """
        allocateInterleaved(self, size)

        Allocate the array with a specific `size` using a NUMA interleaved memory policy.
        """
        self._check_not_allocated()
        self.underlying.allocateInterleaved(size)
        self._mark_allocated()

    def allocateBlocked(self, uint64_t size):
        """
        allocateBlocked(self, size)

        Allocate the array with a specific `size` using blocked memory policy.
        """
        self._check_not_allocated()
        self.underlying.allocateBlocked(size)
        self._mark_allocated()

    def __iter__(self):
        """
        iter(self)

        >>> for v in self: ...

        Iterate over the elements of the collection. This may be called from numba code.
        """
        i =  <{{class_name}}_Iterator>{{class_name}}_Iterator.__new__({{class_name}}_Iterator)
        i.obj = self
        i.it = self.underlying.begin()
        i.end = self.underlying.end()
        return i

    @property
    def address(self):
        return <uintptr_t>&self.underlying

    def as_numpy(self):
        """
        as_numpy(self)

        Return a numpy array that is a view on self.
        """
        return np.frombuffer(self, dtype={{python_type}})

    def __getbuffer__(self, Py_buffer *buffer, int flags):
        self._check_allocated()
        buffer.buf = <char *>self.underlying.data()
        buffer.format = '{{buffer_format}}'
        buffer.internal = NULL
        buffer.itemsize = self.stride
        buffer.len = self.shape * self.stride
        buffer.ndim = 1
        buffer.obj = self
        buffer.readonly = 0
        buffer.shape = &self.shape
        buffer.strides = &self.stride
        buffer.suboffsets = NULL

    def __releasebuffer__(self, Py_buffer *buffer):
        pass

{% call numba.class_(class_name, underlying_type) %}
{% call numba.method_with_body("get", element_type, ["uint64_t"]) %}
    return self[0][arg1]
{% endcall %}
{{numba.method("set", "void", ["uint64_t", element_type])}}
{{numba.method("data", element_type + "*", [])}}
{% endcall %}
{% endmacro %}

_LargeArray_types = {}
{% for element_type, python_type, buffer_format in instantiation_types %}
{{wrap_large_array(element_type, python_type, buffer_format)}}
_LargeArray_types[{{python_type}}] = LargeArray_{{element_type}}
{% endfor %}
LargeArray = make_template_type1("LargeArray", _LargeArray_types)

{{numba.register_all_wrappers()}}
