PHASE 1 OUTLINE

an old and new array

old is used for determining which things to send out + in phase 2 when sending
out short path numbers

figure out which things need short paths sent out

new is continuously updated locally; bitset will be set as well;

using bitset, sync up the new arrays with all hosts using pairwise min
compare old and new: if diff, reset path count + mark source as ready

PHASE 2

we know which messages need to be sent; use the OLD array values and send
out short path messages

receivers should determine if it is necessary to add short path

do we want to track predecessors? going to have to loop thoguh all edges anyways
so there kind of is no point.



- need mirror nodes to have a vector with new updates
- send this to all mirrors

each round of sssp

node looks for thing to send (should be same on ALL proxies for a round)
sends along outgoing
checks if index = round number
if so, send that out to

on receiver end

messages for distance from source can be kept in a vector: take min
NEED TO TRACK IF IT HAS CHANGED TO MAKE IT "READY"

once ALL messages processed, then deal with short path messages (can't use
begin of round as begin of round for first round leads ot incorrect
results)

messages for short path distance: will be set the same by everyone:

read source write destination


for 0 < r < 2n

send smallest not sent message

if position in vector + distance = round (e.g. round 0, source itself should
be 0 + 0)
 then send out shortest distance number




1st round

send out thing
locally, do a min + mark update

distance vector: readany, write destination

SYNC

at this point, all src/dests should have sync'd value

sources can now take the value set aside for num short path propogation:
locally, check, then add if distance matches
at the end, for each edge, add short path value to a TRIM value, no reset
sync trim, add to short path on all hosts

write dest, read source?


that's the first phase.....




- Typos regarding d_s + 1 / not +1; pretty sure in most cases it should be + 1

- Algo 3 line 9: for all sources loop there?


Algorithm for APSP + predecessor and shortest path calculation in words:

BC step: if my round has come (based on when finalized shortest path and sent
it out), then send off dep. value to predecessors
  Problem: we don't have outgoing edges; the predecessor itself would need
  to know the time of its successors
  Alternatively we just set a flag on predecessor...... but that's how we're
  doing it now
    would be easier since it's all going to be timer based now; don't need
    to calculate num pred/num succ I think?

get lowest not "sent" index

for each outgoing edge
  update Lv on each node with lowest not sent index; needs atomic since
  each host runs multiple threads



NEW QUESTIONS:

* Is there anything that is reliant on level by level bfs?

* Observed Bottlenecks:

- sorting the list every round as you do more sources.
  - can be solved if you don't sort every round and maintain a sorted list
    - problem here is now you have to search for where to save a node, i.e.
    mapping from a source to location in array
    - O(n) operation every time you want to write something if you don't save
    it; this is unacceptable vs. one time O(n log n) sort cost
    - if you do maintain it, problem is potential update every time a new
    message comes in to update a source; remove, insert, remap; total O(n)

- more rounds = way more synchronization when I make this distributed
  - How can you reduce the number of rounds while keeping the algorithm
  correct?

* More sources = more space usage: once you get to a high number of nodes, your
number of sources is going to be limited

* Less rounds = less sorts, less synchronization
