/** Per Thread Storage -*- C++ -*-
 * @file
 * @section License
 *
 * This file is part of Galois.  Galoisis a framework to exploit
 * amorphous data-parallelism in irregular programs.
 *
 * Galois is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, version 2.1 of the
 * License.
 *
 * Galois is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with Galois.  If not, see
 * <http://www.gnu.org/licenses/>.
 *
 * @section Copyright
 *
 * Copyright (C) 2016, The University of Texas at Austin. All rights
 * reserved.
 *
 * @section Description
 *
 * Dynamic per-thread storage (dPTS).
 *
 * @author Andrew Lenharth <andrew@lenharth.org>
 */

#ifndef GALOIS_RUNTIME_PERTHREADSTORAGE_H
#define GALOIS_RUNTIME_PERTHREADSTORAGE_H

#include "Galois/Runtime/ThreadPool.h"
#include "Galois/Runtime/HWTopo.h"
#include "Galois/Runtime/SimpleLock.h"

#include <cstddef>

#include <cassert>
#include <vector>
#include <utility>
#include <bitset>

namespace Galois {
namespace Runtime {

class PerBackend {
  static const unsigned MAX_SIZE = 30;
  // 16 byte alignment so vectorized initialization is easier
  // NB(ddn): llvm seems to assume this under some cases because
  // I've seen weird initialization crashes with MIN_SIZE = 3
  static const unsigned MIN_SIZE = 4;
  typedef SimpleLock Lock;

  unsigned int nextLoc;
  char** heads;
  Lock freeOffsetsLock;
  std::vector<std::vector<unsigned> > freeOffsets;
  /**
   * Guards access to non-POD objects that can be accessed after PerBackend
   * is destroyed. Access can occur through destroying PerThread/PerPackage
   * objects with static storage duration, which have a reference to a
   * PerBackend object, which may have be destroyed before the PerThread
   * object itself.
   */
  bool invalid; 

  void initCommon(unsigned maxT);
  static unsigned nextLog2(unsigned size);

public:
  PerBackend(): nextLoc(0), heads(0), invalid(false) {
    freeOffsets.resize(MAX_SIZE);
  }

  PerBackend(const PerBackend&) = delete;
  PerBackend& operator=(const PerBackend&) = delete;

  ~PerBackend() {
    // Intentionally leak heads so that other PerThread operations are
    // still valid after we are gone
    invalid = true;
  }

  char* initPerThread(unsigned maxT);
  char* initPerPackage(unsigned maxT);

  unsigned allocOffset(const unsigned size);
  void deallocOffset(const unsigned offset, const unsigned size);
  void* getRemote(unsigned thread, unsigned offset);
  void* getLocal(unsigned offset, char* base) {
    return &base[offset];
  }
  // faster when (1) you already know the id and (2) shared access to heads is
  // not to expensive; otherwise use getLocal(unsigned,char*)
  void* getLocal(unsigned offset, unsigned id) {
    return &heads[id][offset];
  }

  explicit operator bool() const {
    return offset != ~0;
  }
};

extern __thread char* ptsBase;
PerBackend& getPTSBackend();

extern __thread char* ppsBase;
PerBackend& getPPSBackend();

void initPTS(unsigned maxT);


namespace detail {

class PerThreadStorageBase {
  static constexpr unsigned PTSSize = 4*1024*1024;
  static thread_local uint64_t* storage;
  static std::vector<uint64_t*> heads;
  static std::bitset<PTSSize> mask;
  static unsigned next;

protected:

  PerThreadStorageBase() : offset(~0) {}
  PerThreadStorageBase(PerThreadStorageBase&& rhs) : offset(rhs.offset) {
    rhs.offset = ~0;
  }

  //Fixme: Do we need 16byte alignment (OSX, llvm)?
  static unsigned alloc(unsigned bytes);
  static void dealloc(unsigned offset, unsigned bytes);

  //per-object interface
  unsigned offset;  
  
  void* _getLocal() const {
    return &storage[offset];
  }

  void* _getRemote(unsigned id) const {
    return &heads[id][offset];
  }

};
} // namespace PerThreadStorageBase



template<typename T>
class PerThreadStorage : public detail::PerThreadStorageBase {

public:
  typedef T* pointer;
  typedef T element_type;

  //construct on each thread
  template<typename... Args>
  PerThreadStorage(Args&&... args) {
    //in case we make one of these before initializing the thread pool
    //This will call initPTS for each thread if it hasn't already
    auto& tp = ThreadPool::getThreadPool();

    offset = alloc(sizeof(T));
    for (unsigned n = 0; n < tp.getMaxThreads(); ++n)
      new (_getRemote(n)) T(std::forward<Args>(args)...);
  }

  PerThreadStorage(PerThreadStorage&& rhs) :PerThreadStorageBase(std::forward(rhs)) {}

  ~PerThreadStorage() {
    for (unsigned n = 0; n < ThreadPool::getThreadPool().getMaxThreads(); ++n)
      get(n)->~T();
    dealloc(offset, sizeof(T));
    offset = ~0U;
  }

  //Standard smart pointer idioms

  pointer get() const noexcept {
    return reinterpret_cast<pointer>(_getLocal());
  }

  pointer get(unsigned tid) const noexcept {
    return reinterpret_cast<pointer>(_getRemote(tid));
  }

  void swap(PerThreadStorage& other) noexcept {
    std::swap(offset, other.offset);
  }

  //Smart Pointer functions

  typename std::add_lvalue_reference<T>::type operator*() const {
    return *get();
  }

  pointer operator->() const noexcept {
    return get();
  }


  PerThreadStorage& operator=(PerThreadStorage&& rhs) {
    std::swap(offset, rhs.offset);
    return *this;
  }

  unsigned size() const {
    return ThreadPool::getThreadPool().getMaxThreads();
  }
};



template<typename T>
class PerPackageStorage : public detail::PerThreadStorageBase {

  void* _getRemotePkg(unsigned n) const {
    return _getRemote(ThreadPool::getThreadPool().getLeader(n));
  }
  void* _getLocalPkg() const {
    return _getRemote(ThreadPool::getLeader());
  }

public:
  typedef T* pointer;
  typedef T element_type;

  //construct on each thread
  template<typename... Args>
  PerPackageStorage(Args&&... args) {
    //in case we make one of these before initializing the thread pool
    //This will call initPTS for each thread if it hasn't already
    auto& tp = ThreadPool::getThreadPool();

    offset = alloc(sizeof(T));
    for (unsigned n = 0; n < tp.getMaxPackages(); ++n)
      new (_getRemote(tp.getLeaderForPackage(n))) T(std::forward<Args>(args)...);
  }

  PerPackageStorage(PerPackageStorage&& rhs) :PerThreadStorageBase(std::forward(rhs)) {}

  ~PerPackageStorage() {
    auto& tp = ThreadPool::getThreadPool();
    for (unsigned n = 0; n < tp.getMaxPackages(); ++n)
      get(tp.getLeaderForPackage(n))->~T();
    dealloc(offset, sizeof(T));
    offset = ~0U;
  }

  //Standard smart pointer idioms

  pointer get() const noexcept {
    return reinterpret_cast<pointer>(_getLocalPkg());
  }

  pointer get(unsigned tid) const noexcept {
    return reinterpret_cast<pointer>(_getRemotePkg(tid));
  }

  pointer getByPkg(unsigned pid) const noexcept {
    auto& tp = ThreadPool::getThreadPool();
    return reinterpret_cast<pointer>(_getRemotePkg(tp.getLeaderForPackage(pid)));
  }

  void swap(PerPackageStorage& other) noexcept {
    std::swap(offset, other.offset);
  }

  //Smart Pointer functions

  typename std::add_lvalue_reference<T>::type operator*() const {
    return *get();
  }

  pointer operator->() const noexcept {
    return get();
  }

  PerPackageStorage& operator=(PerPackageStorage&& rhs) {
    std::swap(offset, rhs.offset);
    return *this;
  }

  unsigned size() const {
    return ThreadPool::getThreadPool().getMaxThreads();
  }
};

} // end namespace Runtime
} // end namespace Galois
#endif
